# Go ならわかるシステムプログラミング 第二版の読書メモ

読みながら学んだことの学習メモ

# 使用環境

macOS
Go 1.23.3（本では 1.17.7 を使用していたが、delve が 1.21 以降でないと動作しないとエラーがでたので 1.23.3 を使用。）

# 概要

現在のコンピュータに OS の一部としてインストールされている機能の多くは、アプリケーション。
OS 機能を最大公約するにするなら以下の通り。

- メモリ管理
- プロセス管理
- プロセス間通信
- ファイルシステム
- ネットワーク
- ユーザー管理
- タイマー

これを、ボトムアップではなく馴染みやすい視点で解説。

Go 言語は C 言語の性能と Python の書きやすさを両立。
Go は多くの OS の機能を直接扱え、少ない行数で動くアプリケーションを作成可能。

**Go は C/C++よりも書き始める前のライブラリ収集が簡単らしい。**

Go は 1.17.7 を使用。

## 1.4 デバッガーを使って Hello world の裏側を覗く

使用するデバッガーツールは Delve
1.17.7 を使おうとしたら、Delve で Go のバージョン古すぎるエラーがでたので、今回は 1.23.3 を使用する。

### デバッグ開始

```go
// Println formats using the default formats for its operands and writes to standard output.
// Spaces are always added between operands and a newline is appended.
// It returns the number of bytes written and any write error encountered.
func Println(a ...any) (n int, err error) {
return Fprintln(os.Stdout, a...)
}
```

Fprintln を呼び出すだけの関数で、os.Stdout を渡している

```go
// Fprintln formats using the default formats for its operands and writes to w.
// Spaces are always added between operands and a newline is appended.
// It returns the number of bytes written and any write error encountered.
func Fprintln(w io.Writer, a ...any) (n int, err error) {
	p := newPrinter()
	p.doPrintln(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
```

最初に文字列をフォーマット文字列に従って整形する p を newPrinter で作成、出力する文字列を生成している。

3 行目で w.Write に渡して書き込んでいる。w=os.Stdout

```go
// Write writes len(b) bytes from b to the File.
// It returns the number of bytes written and an error, if any.
// Write returns a non-nil error when n != len(b).
func (f *File) Write(b []byte) (n int, err error) {
	if err := f.checkValid("write"); err != nil {
		return 0, err
	}
	n, e := f.write(b)
	if n < 0 {
		n = 0
	}
	if n != len(b) {
		err = io.ErrShortWrite
	}

	epipecheck(f, e)

	if e != nil {
		err = f.wrapErr("write", e)
	}

	return n, err
}

```

後半はエラーチェックなので、前半に注目。
f.write という非公開メソッドを呼んでいる。

```go
// write writes len(b) bytes to the File.
// It returns the number of bytes written and an error, if any.
func (f *File) write(b []byte) (n int, err error) {
	n, err = f.pfd.Write(b)
	runtime.KeepAlive(f)
	return n, err
}
```

write は構造体 f のプライベートメンバーである pfd のメソッドである Write を呼び出している。
ここから先は OS 依存になるらしい。

```go
// Write implements io.Writer.
func (fd *FD) Write(p []byte) (int, error) {
~~~~
	var nn int
	for {
		max := len(p)
		if fd.IsStream && max-nn > maxRW {
			max = nn + maxRW
		}
		n, err := ignoringEINTRIO(syscall.Write, fd.Sysfd, p[nn:max])
		if n > 0 {
			if n > max-nn {
				// This can reportedly happen when using
				// some VPN software. Issue #61060.
				// If we don't check this we will panic
				// with slice bounds out of range.
				// Use a more informative panic.
				panic("invalid return from write: got " + itoa.Itoa(n) + " from a write of " + itoa.Itoa(max-nn))
			}
			nn += n
		}
		if nn == len(p) {
			return nn, err
		}
		if err == syscall.EAGAIN && fd.pd.pollable() {
			if err = fd.pd.waitWrite(fd.isFile); err == nil {
				continue
			}
		}
		if err != nil {
			return nn, err
		}
		if n == 0 {
			return nn, io.ErrUnexpectedEOF
		}
	}
}
```

for ループに囲まれ、送信が終わるまで何度も syscall.Write()を呼んでいる。
これはシステムコールという関数らしい。
現状は「システムコールにはいくつも種類があって、アプリケーションのプログラム単体では達成できない仕事を、OS のカーネルに依頼するためにつかう」理解で OK。ここでは「プログラム外のターミナルに対して文字列を出力する」という仕事を依頼。

# この章でわかったこと

- Go 言語で OS 機能を扱っているレイヤーまで簡単に降りていってコードを追うことができる
- "システムコール"を使ってアプリケーションのプログラムでは関与できないタスクを扱える。ただ、このシステムコール自体の具体的な挙動はまだよくわからない。

# 問題

定義ジャンプとか参照チェックだったので割愛
